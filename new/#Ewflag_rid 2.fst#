module Ewflag_rid

//open SeqUtils
//module S = Set_extended_new
module L = FStar.List.Tot

#set-options "--query_stats"

let cf = s:(int * bool)//{fst s = 0 ==> snd s <> true}

let rec mem_rid (rid:nat) (s:list (nat * cf)) 
  : Tot (b:bool{b = true <==> (exists cf. L.mem (rid, cf) s)}) =
  match s with
  |[] -> false
  |x::xs -> fst x = rid || mem_rid rid xs

let rec unique (l:list (nat * cf)) =
  match l with
  |[] -> true
  |x::xs -> not (mem_rid (fst x) xs) && unique xs 

// the concrete state type
type concrete_st = l:list (nat & cf){unique l} // (replica_id, ctr, flag) //replica ids are unique
 
let init_st = []
 
let rec get_cf (rid:nat) (s:concrete_st) //{mem_rid rid s}) 
  : Tot (r:cf{(mem_rid rid s <==> L.mem (rid,r) s) /\
              (not (mem_rid rid s) ==> r = (0,false))}) =
  match s with
  |[] -> (0, false)
  |(rid1,cf)::xs -> if rid = rid1 then cf else get_cf rid xs

let rec rem_rid (rid:nat) (s:concrete_st) 
  : Tot (r:concrete_st{(forall id. mem_rid id r <==> mem_rid id s /\ id <> rid) /\ not (mem_rid rid r) /\
                       (forall id. mem_rid id r ==> (get_cf id s = get_cf id r)) /\
                       (forall e. L.mem e r <==> L.mem e s /\ fst e <> rid)}) 
    (decreases s) =
  match s with
  |[] -> []
  |x::xs -> if rid = fst x then (assert (forall e. L.mem e s /\ fst e <> rid ==> L.mem e xs);  xs) else x::rem_rid rid xs

let eq_id (a b:concrete_st) =
  (forall id. mem_rid id a <==> mem_rid id b)

let eq (a b:concrete_st) =
  eq_id a b /\
  (forall rid. mem_rid rid a ==> (get_cf rid a = get_cf rid b))
  //(forall e. L.mem e a <==> L.mem e b)

// few properties of equivalence relation
let symmetric (a b:concrete_st) 
  : Lemma (requires eq a b)
          (ensures eq b a) = ()

let transitive (a b c:concrete_st)
  : Lemma (requires eq a b /\ eq b c)
          (ensures eq a c) = ()

let eq_is_equiv (a b:concrete_st)
  : Lemma (requires a == b)
          (ensures eq a b) = ()

// operation type
type app_op_t:eqtype =
  |Enable 
  |Disable

type timestamp_t = pos 

type op_t = timestamp_t & (nat (*replica_id*) & app_op_t)

let get_rid (_,(rid,_)) = rid

let rec update (rid:nat) (s:concrete_st{mem_rid rid s}) (cf1:cf{snd cf1 = true})
  : Tot (r:concrete_st{(forall id. mem_rid id s <==> mem_rid id r) /\ L.mem (rid, cf1) r /\
                        get_cf rid r = cf1 /\
                       (forall id. mem_rid id s /\ id <> rid ==> (get_cf id s = get_cf id r)) /\
                       (forall e. L.mem e r /\ fst e <> rid <==> L.mem e s /\ fst e <> rid)}) =
  match s with
  |[x] -> [(fst x, cf1)]
  |x::xs -> if fst x = rid then (rid, cf1)::xs else x::update rid xs cf1

// apply an operation to a state
let rec do (s:concrete_st) (o:op_t) 
  : (r:concrete_st{(Enable? (snd (snd o)) ==> (forall id. mem_rid id r <==> mem_rid id s \/ id = get_rid o) /\
                                       (not (mem_rid (get_rid o) s) ==> L.mem ((get_rid o), (1, true)) r /\
                                (forall id cf. L.mem (id, cf) s \/ (id, cf) = (get_rid o, (1, true)) <==> L.mem (id, cf) r)) /\
          (mem_rid (get_rid o) s ==> (L.mem (get_rid o, (fst (get_cf (get_rid o) s) + 1, true)) r) /\
                            fst (get_cf (get_rid o) r) = fst (get_cf (get_rid o) s) + 1) /\
             (forall id. id <> get_rid o ==> (get_cf id s = get_cf id r))) /\
                   (Disable? (snd (snd o)) ==> (forall id. mem_rid id r <==> mem_rid id s) /\
                     (forall id. fst (get_cf id s) = fst (get_cf id r) /\ snd (get_cf id r) = false))}) =
  match o with
  |(_, (rid, Enable)) -> if mem_rid rid s then update rid s (fst (get_cf rid s) + 1, true) else (rid, (1, true))::s
  |(_, (rid, Disable)) -> match s with
                         |[] -> []
                         |(rid,(c,_))::xs -> (rid,(c,false))::do xs o

let pre_cf (l a b:cf) = true // ctr & flag =
  
  //fst a >= fst l /\ fst b >= fst l 
  (*(((fst l = fst a) /\ snd l = false) ==> snd a <> true) /\
  (((fst l = fst b) /\ snd l = false) ==> snd b <> true) /\
  ((fst l = fst a /\ fst l = fst b /\ snd l = false) ==> (snd a <> true /\ snd b <> true))*)

let merge_flag (l a:cf) (b:cf{pre_cf l a b}) =
  let lc = fst l in
  let ac = fst a in
  let bc = fst b in
  let af = snd a in
  let bf = snd b in
    if af && bf then true
      else if not af && not bf then false
        else if af then ac > lc
          else bc > lc

let merge_pre (l a b:concrete_st) =
  (forall rid. mem_rid rid l ==> (mem_rid rid a /\ mem_rid rid b)) /\
  (forall rid. pre_cf (get_cf rid l) (get_cf rid a) (get_cf rid b))

// concrete merge operation
let merge_cf (lca s1:cf) (s2:cf{pre_cf lca s1 s2}) 
  : Tot (r:cf{fst r = fst s1 + fst s2 - fst lca} (*{((lca = s1) ==> (r = s2)) /\ ((lca = s2) ==> (r = s1))}*)) =
  (fst s1 + fst s2 - fst lca, merge_flag lca s1 s2)

#push-options "--z3rlimit 500 --fuel 1 --ifuel 1"
let rec concrete_merge (lca s1 s2:concrete_st) 
  : Pure concrete_st
    (requires merge_pre lca s1 s2)
    (ensures (fun r -> (forall rid. mem_rid rid r <==> (mem_rid rid lca \/ mem_rid rid s1 \/ mem_rid rid s2)) /\
                    (forall id. (get_cf id r = merge_cf (get_cf id lca) (get_cf id s1) (get_cf id s2))))) (*/\
                    (forall e. L.mem e r <==> (mem_rid (fst e) lca \/ mem_rid (fst e) s1 \/ mem_rid (fst e) s2) /\
                        snd e = merge_cf (get_cf (fst e) lca) (get_cf (fst e) s1) (get_cf (fst e) s2)))*)    
    (decreases %[lca;s1;s2]) =
  match lca, s1, s2 with
  |[],[],[] -> []
  |(rid,cf)::xs,_,_ -> (rid, merge_cf cf (get_cf rid s1) (get_cf rid s2))::concrete_merge xs (rem_rid rid s1) (rem_rid rid s2)
  |[],(rid,cf)::ys,_ -> (rid, merge_cf (get_cf rid lca) cf (get_cf rid s2))::concrete_merge [] (rem_rid rid s1) (rem_rid rid s2)
  |[],[],(rid,cf)::zs -> (rid, merge_cf (get_cf rid lca) (get_cf rid s1) cf)::concrete_merge [] [] zs
#pop-options

let lem (a:int)
  : Lemma ((a + 2) + (a + 1) - (a + 1) = a + 2) = ()

#push-options "--z3rlimit 100"
let prop1 (l:concrete_st) (o1 o2 o3:op_t)
  : Lemma (requires fst o1 <> fst o3 /\ Enable? (snd (snd o1)) /\ Disable? (snd (snd o3)) /\ //Enable? (snd (snd o2)) /\
                    get_rid o1 = get_rid o2 /\ get_rid o3 <> get_rid o1 /\
                    merge_pre (do l o1) (do (do l o1) o2) (do (do l o3) o1))
                    //resolve_conflict o1 o3 = First_then_second) //o3.o1
          (ensures eq (concrete_merge (do l o1) (do (do l o1) o2) (do (do l o3) o1)) (do (do (do l o3) o1) o2)) = 
  let a' = do l o1 in let a = do (do l o1) o2 in let b = do l o3 in
  let r1 = get_rid o1 in let r2 = get_rid o2 in let r3 = get_rid o3 in
  let lhs = (concrete_merge (do l o1) (do (do l o1) o2) (do (do l o3) o1)) in
  let rhs = (do (do (do l o3) o1) o2) in
  if Enable? (snd (snd o2)) then 
    ((*assume (fst (get_cf r1 a') = fst (get_cf r1 l) + 1 /\ snd (get_cf r1 a') = true /\
             fst (get_cf r1 a) = fst (get_cf r1 a') + 1 /\ snd (get_cf r1 a) = true /\
             fst (get_cf r1 a) = fst (get_cf r1 l) + 2);
     assume (forall id. id <> r1 ==> get_cf id l = get_cf id a' /\ get_cf id l = get_cf id a);
     assume (forall id. fst (get_cf id l) = fst (get_cf id b) /\ snd (get_cf id b) = false);
     assume (eq_id lhs rhs);*)
     assume (fst (get_cf r1 (do (do (do l o3) o1) o2)) = fst (get_cf r1 l) + 2); 
     assume (fst (get_cf r1 (do l o1)) = fst (get_cf r1 l) + 1);
     assume (fst (get_cf r1 (do (do l o1) o2)) = fst (get_cf r1 l) + 2); 
     assume (fst (get_cf r1 (do (do l o3) o1)) = fst (get_cf r1 l) + 1); 
     assume (fst (get_cf r1 lhs) = fst (get_cf r1 (do (do l o1) o2)) + fst (get_cf r1 (do (do l o3) o1)) - fst (get_cf r1 (do l o1))); 
     assume (fst (get_cf r1 lhs) = (fst (get_cf r1 l) + 2) + (fst (get_cf r1 l) + 1) - (fst (get_cf r1 l) + 1));
     lem (fst (get_cf r1 l));
     assert ((fst (get_cf r1 l) + 2) + (fst (get_cf r1 l) + 1) - (fst (get_cf r1 l) + 1) = fst (get_cf r1 l) + 2); 
     assert (fst (get_cf r1 lhs) = fst (get_cf r1 l) + 2); 
     assert (forall id. id = r1 ==> fst (get_cf id lhs) = fst (get_cf id rhs));
     ())
  else admit()


let prop2 (s s':concrete_st) (o1 o2:op_t)
  : Lemma (requires merge_pre s (do s o2) s' /\ eq (concrete_merge s (do s o2) s') (do s' o2) /\
                    merge_pre (do s o1) (do (do s o1) o2) (do s' o1))
          (ensures eq (concrete_merge (do s o1) (do (do s o1) o2) (do s' o1)) (do (do s' o1) o2)) = ()

let prop3 (s s':concrete_st)
  : Lemma (requires eq (concrete_merge s s s') s' /\
                    (forall o2'. eq (concrete_merge s (do s o2') s') (do s' o2')))
          (ensures (forall o2 o2'. (fst o2 <> fst o2') ==> eq (concrete_merge s (do (do s o2') o2) s') (do (do s' o2') o2))) = ()

let prop4 (l s:concrete_st) (o1 o2 o3 o3':op_t)
  : Lemma (requires fst o2 <> fst o3 /\ //resolve_conflict o2 o3 = First_then_second /\ //o3.o2
                    eq (concrete_merge (do l o1) (do (do l o1) o2) (do (do s o3) o1)) (do (do (do s o3) o1) o2))
          (ensures eq (concrete_merge (do l o1) (do (do l o1) o2) (do (do (do s o3') o3) o1)) 
                   (do (do (do (do s o3') o3) o1) o2)) = ()

let prop5 (s s':concrete_st)
  : Lemma (eq (concrete_merge s s s') s' /\ 
           eq (concrete_merge s s' s) s') = admit()



let lem_merge1 (s:concrete_st) (op:op_t) 
  : Lemma (requires merge_pre s s (do s op)) // /\ Enable? (snd op) /\  (mem_rid (get_rid op) s) )
          (ensures eq (concrete_merge s s (do s op)) (do s op)) = 
  //let id = get_rid op in
  //assert (forall id. mem_rid id s ==> get_cf id (do s op) = merge_cf (get_cf id s) (get_cf id s) (get_cf id (do s op))); 
  //assert (get_cf (get_rid op) s = (0,false));
  //assert (get_cf (get_rid op) (do s op) = (1,true));
  //assume (pre_cf (get_cf id s) (get_cf id s) (get_cf id (do s op)));
  //assume (get_cf id (do s op) = merge_cf (get_cf id s) (get_cf id s) (get_cf id (do s op)));
  //assume (forall id. mem_rid id (do s op) ==> get_cf id (do s op) = merge_cf (get_cf id s) (get_cf id s) (get_cf id (do s op)));
  test (concrete_merge s s (do s op)) (do s op);
  ()

(*let test5 (l a' a b:concrete_st)
  : Lemma (requires merge_pre l a b /\ merge_pre l a' b /\ merge_pre a' a (concrete_merge l a' b))
          (ensures eq (concrete_merge l a b) (concrete_merge a' a (concrete_merge l a' b))) = 
  test (concrete_merge l a b) (concrete_merge a' a (concrete_merge l a' b))*)


#push-options "--z3rlimit 300"
let lem_merge2 (s s':concrete_st) (op op':op_t)
  : Lemma 
    (requires merge_pre s s' (do s op) /\ ///\ Enable? (snd (snd op)) /\ Disable? (snd (snd op')) /\ s <> [] /\ s' <> [] /\
              (s <> [] ==> s' <> []) /\ 
              (forall id. mem_rid id s ==> mem_rid id s' /\ fst (get_cf id s') >= fst (get_cf id s) /\
                     ((fst (get_cf id s') = fst (get_cf id s) /\ snd (get_cf id s) = false) ==> snd (get_cf id s) <> true)) /\
              get_rid op = get_rid op' /\
              merge_pre (do s op') (do s' op') (do (do s op') op) /\
              eq (concrete_merge s s' (do s op)) (do s' op))
    (ensures eq (concrete_merge (do s op') (do s' op') (do (do s op') op)) (do (do s' op') op)) = 
  test (concrete_merge s s' (do s op)) (do s' op);
  test (concrete_merge (do s op') (do s' op') (do (do s op') op)) (do (do s' op') op); admit() //do_prop s op'; do_prop s' op'; do_prop (do s op') op; do_prop (do s' op') op

#push-options "--z3rlimit 400"
let lem_merge3' (l a b c:concrete_st) (op op1 op':op_t)
  : Lemma 
    (requires merge_pre l a b /\ eq (concrete_merge l a b) c /\ 
              merge_pre l a (do b op) /\ eq (concrete_merge l a (do b op)) (do c op) /\
              fst op1 <> fst op' /\ get_rid op1 <> get_rid op' /\
              merge_pre l a (do (do b op1) op'))
    (ensures eq (concrete_merge l a (do (do b op1) op')) (do (do c op1) op')) = 
  test (concrete_merge l a b) c;
  test (concrete_merge l a (do b op)) (do c op);
  test (concrete_merge l a (do (do b op1) op')) (do (do c op1) op');
  ()
                                   
let lem_merge3 (l a b c:concrete_st)
  : Lemma 
    (requires merge_pre l a b /\ eq (concrete_merge l a b) c /\ 
              (forall (op:op_t). merge_pre l a (do b op) /\ eq (concrete_merge l a (do b op)) (do c op)))
    (ensures (forall (op op':op_t). (fst op <> fst op') /\ get_rid op = get_rid op' /\ merge_pre l a (do (do b op) op') ==> 
                                   eq (concrete_merge l a (do (do b op) op')) (do (do c op) op'))) = ()
    
let lem_merge4 (s s':concrete_st) (op:op_t{Enable? (snd (snd op))}) (op':op_t{Disable? (snd (snd op))})
  : Lemma 
    (requires //merge_pre (do s op) (do s' op) (do s op) /\
              //merge_pre (do s op) (do (do s' op') op) (do s op) /\
              eq (concrete_merge (do s op) (do s' op) (do s op)) (do s' op))
    (ensures eq (concrete_merge (do s op) (do (do s' op') op) (do s op)) (do (do s' op') op)) = ()

#push-options "--z3rlimit 100"
let lem_merge5 (s s':concrete_st) (op:op_t{Enable? (snd (snd op))}) (op':op_t{Disable? (snd (snd op'))}) (op'' op1: op_t)
  : Lemma 
    (requires merge_pre (do s op) (do (do s' op') op) (do (do s op) op'') /\
              merge_pre (do s op) (do (do (do s' op1) op') op) (do (do s op) op'') /\
              eq (concrete_merge (do s op) (do (do s' op') op) (do (do s op) op''))
                 (do (do (do s' op') op) op''))
    (ensures eq (concrete_merge (do s op) (do (do (do s' op1) op') op) (do (do s op) op''))
                (do (do (do (do s' op1) op') op) op'')) = admit()    

(*
let rec concrete_merge (lca s1 s2:concrete_st) 
  : Pure concrete_st
    (requires merge_pre lca s1 s2) //(forall rid. (mem_rid rid lca /\ mem_rid rid s1 /\ mem_rid rid s2) ==>
                      //merge_pre (get_cf rid lca) (get_cf rid s1) (get_cf rid s2)))
    (ensures (fun r -> (forall rid. mem_rid rid r <==> (mem_rid rid lca \/ mem_rid rid s1 \/ mem_rid rid s2)) /\
                    (forall id. (get_cf id r = merge_cf (get_cf id lca) (get_cf id s1) (get_cf id s2))) /\
                    (forall e. L.mem e r <==> (mem_rid (fst e) lca \/ mem_rid (fst e) s1 \/ mem_rid (fst e) s2) /\
                             snd e = merge_cf (get_cf (fst e) lca) (get_cf (fst e) s1) (get_cf (fst e) s2)) (*/\
                    (forall id. mem_rid id lca /\ mem_rid id s1 /\ mem_rid id s2 ==>
                           (get_cf id r = merge_cf (get_cf id lca) (get_cf id s1) (get_cf id s2))) /\
                    (forall id. not (mem_rid id lca) /\ mem_rid id s1 /\ (mem_rid id s2) ==>
                           (get_cf id r = merge_cf (0,false) (get_cf id s1) (get_cf id s2))) /\
                    (forall id. not (mem_rid id lca) /\ not (mem_rid id s1) /\ (mem_rid id s2) ==>
                           (get_cf id r = merge_cf (0,false) (0,false) (get_cf id s2))) /\
                    (forall id. mem_rid id lca /\ mem_rid id s1 /\ not (mem_rid id s2) ==>
                           (get_cf id r = merge_cf (get_cf id lca) (get_cf id s1) (0,false))) /\
                    (forall id. mem_rid id lca /\ not (mem_rid id s1) /\ not (mem_rid id s2) ==>
                           (get_cf id r = merge_cf (get_cf id lca) (0,false) (0,false))) /\
                    (forall id. mem_rid id lca /\ not (mem_rid id s1) /\ (mem_rid id s2) ==>
                           (get_cf id r = merge_cf (get_cf id lca) (0,false) (get_cf id s2))) /\
                    (forall id. not (mem_rid id lca) /\ not (mem_rid id s1) /\ (mem_rid id s2) ==>
                           (get_cf id r = merge_cf (0,false) (0,false) (get_cf id s2))*)))      
                   
    (decreases %[lca;s1;s2]) =
  match lca, s1, s2 with
  |[],[],[] -> []
  |(rid,cf)::xs,_,_ -> (rid, merge_cf cf (get_cf rid s1) (get_cf rid s2))::concrete_merge xs (rem_rid rid s1) (rem_rid rid s2)
  |[],(rid,cf)::ys,_ -> (rid, merge_cf (get_cf rid lca) cf (get_cf rid s2))::concrete_merge [] (rem_rid rid s1) (rem_rid rid s2)
  |[],[],(rid,cf)::zs -> (rid, merge_cf (get_cf rid lca) (get_cf rid s1) cf)::concrete_merge [] [] zs
  
  (*match lca, s1, s2 with
  |[],[],[] -> []
  |(rid,cf)::xs,_,_ -> if mem_rid rid s1 && mem_rid rid s2 then
                 (rid, merge_cf cf (get_cf rid s1) (get_cf rid s2))::concrete_merge xs (rem_rid rid s1) (rem_rid rid s2)
                     else if mem_rid rid s1 then
                 (rid, merge_cf cf (get_cf rid s1) (0,false))::concrete_merge xs (rem_rid rid s1) s2
                     else if mem_rid rid s2 then
                 (rid, merge_cf cf (0,false) (get_cf rid s2))::concrete_merge xs s1 (rem_rid rid s2)
                     else 
                 (rid, merge_cf cf (0,false) (0,false))::concrete_merge xs s1 s2
  |[],(rid,cf)::ys,_ -> if mem_rid rid s2 then
                         (rid, merge_cf (0,false) cf (get_cf rid s2))::concrete_merge [] (rem_rid rid s1) (rem_rid rid s2)
                      else 
                         (rid, merge_cf (0,false) cf (0,false))::concrete_merge [] (rem_rid rid s1) s2
  |[],[],(rid,cf)::zs -> s2*)
  
let do_prop (s:concrete_st) (o:op_t)
  : Lemma (ensures (let r = do s o in
          (Enable? (snd (snd o)) ==> (forall id. mem_rid id r <==> mem_rid id s \/ id = get_rid o) /\
                                       (not (mem_rid (get_rid o) s) ==> L.mem ((get_rid o), (1, true)) r /\
                                (forall id cf. L.mem (id, cf) s \/ (id, cf) = (get_rid o, (1, true)) <==> L.mem (id, cf) r) /\
          (mem_rid (get_rid o) s ==> (L.mem (get_rid o, (fst (get_cf (get_rid o) s) + 1, true)) r)))) /\
                   (Disable? (snd (snd o)) ==> (forall id. mem_rid id r <==> mem_rid id s)))) = ()


let rec win (s:concrete_st) : (b:bool{b = true <==> (exists id. mem_rid id s /\ snd (get_cf id s) = true)}) =
  match s with
  |[] -> false
  |x::xs -> snd (snd x) = true || win xs


let rec test1 (a b:concrete_st)
  : Lemma (requires (forall id. mem_rid id a <==> mem_rid id b) /\
                    (forall id. mem_rid id a ==> (get_cf id a = get_cf id b)))
          (ensures (forall e. L.mem e a ==> L.mem e b))
                //   (forall e. L.mem e b ==> L.mem e a))
          (decreases %[a;b]) = 
  match a, b with
  |[],[] -> ()
  |x::xs,y::ys -> assert (mem_rid (fst x) b);
               assert (snd x = get_cf (fst x) b);
               assert (L.mem x b);
               
               (); test1 xs (rem_rid (fst x) b)

let rec test11 (a b:concrete_st)
  : Lemma (requires (forall e. L.mem e a <==> L.mem e b))
          (ensures (forall id. mem_rid id a <==> mem_rid id b) /\
                    (forall id. mem_rid id a ==> (get_cf id a = get_cf id b)))
          
                //   (forall e. L.mem e b ==> L.mem e a))
          (decreases %[a;b]) = 
  match a, b with
  |[],[] -> ()
  |x::xs,y::ys -> (*assert (mem_rid (fst x) b);
               assert (snd x = get_cf (fst x) b);
               assert (L.mem x b);
               
               ();*) test11 xs (rem_rid (fst x) b)
               
let rec test2 (a b:concrete_st)
  : Lemma (requires (forall id. mem_rid id a <==> mem_rid id b) /\
                    (forall id. mem_rid id a ==> (get_cf id a = get_cf id b)))
          (ensures //(forall e. L.mem e a ==> L.mem e b))
                   (forall e. L.mem e b ==> L.mem e a))
          (decreases %[b;a]) = 
  match a, b with
  |[],[] -> ()
  |x::xs,y::ys -> assert (mem_rid (fst y) a);
               assert (snd y = get_cf (fst y) a);
               assert (L.mem y a);
               
               (); test2 (rem_rid (fst y) a) ys

let test3 (a b:concrete_st)
  : Lemma (requires (forall id. mem_rid id a <==> mem_rid id b) /\
                    (forall id. mem_rid id a ==> (get_cf id a = get_cf id b)))
          (ensures (forall e. L.mem e a <==> L.mem e b)) =
  test1 a b; test2 a b

let test4 (a b:concrete_st)
  : Lemma (requires (forall e. L.mem e a <==> L.mem e b)) 
          (ensures (forall id. mem_rid id a <==> mem_rid id b) /\
                    (forall id. mem_rid id a ==> (get_cf id a = get_cf id b))) =
  test11 a b

let test (a b:concrete_st)
  : Lemma (ensures (forall e. L.mem e a <==> L.mem e b) <==>
                   ((forall id. mem_rid id a <==> mem_rid id b) /\
                    (forall id. mem_rid id a ==> (get_cf id a = get_cf id b))))
          [SMTPat (forall e. L.mem e a <==> L.mem e b)] =
  admit() 

*)


(*let rec mem_rid (rid:nat) (s:list (nat * (int * bool))) : Tot bool =
  match s with
  |[] -> false
  |x::xs -> fst x = rid || mem_rid rid xs

let rec unique (l:list (nat * (int * bool))) =
  match l with
  |[] -> true
  |x::xs -> not (mem_rid (fst x) xs) && unique xs 

// the concrete state type
type concrete_st = l:list (nat & (int & bool)){unique l} // (replica_id, ctr, flag) //replica ids are unique

let init_st = []

let eq (a b:concrete_st) =
  (forall e. L.mem e a <==> L.mem e b)

// few properties of equivalence relation
let symmetric (a b:concrete_st) 
  : Lemma (requires eq a b)
          (ensures eq b a) = ()

let transitive (a b c:concrete_st)
  : Lemma (requires eq a b /\ eq b c)
          (ensures eq a c) = ()

let eq_is_equiv (a b:concrete_st)
  : Lemma (requires a == b)
          (ensures eq a b) = ()

// operation type
type app_op_t:eqtype =
  |Enable : nat (*replica_id*) -> app_op_t
  |Disable : nat (*replica_id*) -> app_op_t

type timestamp_t = pos 

type op_t = timestamp_t & app_op_t

let get_rid (op:op_t) =
  match snd op with
  |Enable id -> id
  |Disable id -> id

let rec get_cf (rid:nat) (s:concrete_st{mem_rid rid s}) : Tot (int * bool) =
  match s with
  |[] -> (0, false)
  |(rid1,cf)::xs -> if rid = rid1 then cf else get_cf rid xs

let rec rem_rid (rid:nat) (s:concrete_st) 
  : Tot (r:concrete_st{forall id. mem_rid id r <==> mem_rid id s /\ id <> rid}) 
    (decreases s) =
  match s with
  |[] -> []
  |x::xs -> if rid = fst x then xs else x::rem_rid rid xs

let rec update (rid:nat) (s:concrete_st{mem_rid rid s}) (c:int) (f:bool)
  : Tot (r:concrete_st{forall id. mem_rid id s <==> mem_rid id r}) =
  match s with
  |[x] -> [(rid, (c, f))]
  |x::xs -> if fst x = rid then (rid, (c, f))::xs else x::update rid xs c f

// apply an operation to a state
let do (s:concrete_st) (o:op_t) 
  : (r:concrete_st{(Enable? (snd o) ==> (forall id. mem_rid id r <==> mem_rid id s \/ id = get_rid o)) /\
                   (Disable? (snd o) ==> (forall id. mem_rid id r <==> mem_rid id s) /\
                                        (~ (mem_rid (get_rid o) s) <==> ~ (mem_rid (get_rid o) r)))}) =
  match snd o with
  |Enable rid -> if mem_rid rid s then update rid s (fst (get_cf rid s) + 1) true else (rid, (1, true))::s
  |Disable rid -> if mem_rid rid s then update rid s (fst (get_cf rid s)) false else s

let merge_flag (l a b:(int * bool)) : Tot bool =
  let lc = fst l in
  let ac = fst a in
  let bc = fst b in
  let af = snd a in
  let bf = snd b in
    if af && bf then true
      else if not af && not bf then false
        else if af then ac - lc > 0
          else bc - lc > 0

//let merge_pre (l a b:(int * bool)) =
  //fst a >= fst l /\ fst b >= fst l

let merge_pre (l a b:concrete_st) =
  (forall rid. mem_rid rid l ==> (mem_rid rid a /\ mem_rid rid b)) (*/\
  (forall rid. mem_rid rid l ==> (fst (get_cf rid a) >= fst (get_cf rid l)) /\ 
                           (fst (get_cf rid b) >= fst (get_cf rid l)))*)

// concrete merge operation
let merge_cf (lca s1:(int * bool)) (s2:(int * bool)(*{merge_pre lca s1 s2}*)) : Tot (int * bool) =
  (fst s1 + fst s2 - fst lca, merge_flag lca s1 s2)

#push-options "--fuel 1 --ifuel 1"
let rec concrete_merge (lca s1 s2:concrete_st) 
  : Pure concrete_st
    (requires merge_pre lca s1 s2) //(forall rid. (mem_rid rid lca /\ mem_rid rid s1 /\ mem_rid rid s2) ==>
                      //merge_pre (get_cf rid lca) (get_cf rid s1) (get_cf rid s2)))
    (ensures (fun r -> (forall rid. mem_rid rid r <==> (mem_rid rid lca \/ mem_rid rid s1 \/ mem_rid rid s2)) ///\
                   // ((lca = s1) ==> eq r s2)  
                   (*/\(forall rid. mem_rid rid r ==>
                      (get_cf rid r = merge_cf (get_cf rid lca) (get_cf rid s1) (get_cf rid s2))*))) 
    (decreases %[lca;s1;s2]) =
  match lca, s1, s2 with
  |[],[],[] -> []
  |(rid,cf)::xs,_,_ -> if mem_rid rid s1 && mem_rid rid s2 then
                 (rid, merge_cf cf (get_cf rid s1) (get_cf rid s2))::concrete_merge xs (rem_rid rid s1) (rem_rid rid s2)
                     else if mem_rid rid s1 then
                 (rid, merge_cf cf (get_cf rid s1) (0,false))::concrete_merge xs (rem_rid rid s1) s2
                     else if mem_rid rid s2 then
                 (rid, merge_cf cf (0,false) (get_cf rid s2))::concrete_merge xs s1 (rem_rid rid s2)
                     else 
                 (rid, merge_cf cf (0,false) (0,false))::concrete_merge xs s1 s2
  |[],(rid,cf)::ys,_ -> if mem_rid rid s2 then
                         (rid, merge_cf (0,false) cf (get_cf rid s2))::concrete_merge [] (rem_rid rid s1) (rem_rid rid s2)
                      else 
                         (rid, merge_cf (0,false) cf (0,false))::concrete_merge [] (rem_rid rid s1) s2
  |[],[],(rid,cf)::zs -> s2
#pop-options

let mpre (l a b:concrete_st) =
  (forall rid. mem_rid rid l ==> (mem_rid rid a /\ mem_rid rid b)) /\
  (forall rid. mem_rid rid l ==> (fst (get_cf rid a) >= fst (get_cf rid l)) /\ 
                           (fst (get_cf rid b) >= fst (get_cf rid l)))

#push-options "--z3rlimit 50"
let lem_merge1 (s: concrete_st) (op: op_t) 
  : Lemma (requires mpre s s (do s op) /\ Enable? (snd op) /\
                    (forall rid. mem_rid rid s /\ fst (get_cf rid s) = 0 ==> snd (get_cf rid s) <> true))
          (ensures (eq (concrete_merge s s (do s op)) (do s op))) = ()
          
let lem_merge3 (l a b c : concrete_st)
  : Lemma 
    (requires mpre l a b /\ 
              (eq (concrete_merge l a b) c) /\ (forall (op: op_t). mpre l a (do b op) /\ (eq (concrete_merge l a (do b op)) (do c op) )))
    (ensures (forall (op op' : op_t). (fst op <> fst op') /\ mpre l a (do (do b op) op') ==> (eq (concrete_merge l a (do (do b op) op')) (do (do c op) op')) )) = ()*)
    
