module App

open FStar.Seq
open FStar.Ghost
module L = FStar.List.Tot

#set-options "--query_stats"
// the concrete state type
// It is a list of pairs of timestamp and message ordered in descending order of timestamps
type concrete_st = seq nat

// init state
let init_st = empty

// equivalence between 2 concrete states
let eq (a b:concrete_st) =
  a == b

// few properties of equivalence relation
let symmetric (a b:concrete_st) 
  : Lemma (requires eq a b)
          (ensures eq b a) = ()

let transitive (a b c:concrete_st)
  : Lemma (requires eq a b /\ eq b c)
          (ensures eq a c) = ()

let eq_is_equiv (a b:concrete_st)
  : Lemma (requires a == b)
          (ensures eq a b) = ()

// operation type
// (the only operation is append, so unit is fine)
type app_op_t:eqtype = unit

// apply an operation to a state
let do (s:concrete_st) (op:op_t) : concrete_st = cons (fst op) s

let lem_do (a b:concrete_st) (op:op_t)
   : Lemma (requires eq a b)
           (ensures eq (do a op) (do b op)) = ()
           
//conflict resolution
let resolve_conflict (x:op_t) (y:op_t{fst x <> fst y}) : (l:log{(forall e. mem e l <==> (e == x \/ e == y))}) =
  if lt (fst y) (fst x)
    then cons y (cons x empty)
      else cons x (cons y empty)

let resolve_conflict_prop (x y:op_t)
  : Lemma (requires fst x <> fst y)
          (ensures (lt (fst y) (fst x) <==> last (resolve_conflict x y) = x) /\
                   (last (resolve_conflict x y) <> x <==> lt (fst x) (fst y)))
  = ()

(*val pos : id:nat
        -> l:seq nat {mem id l}
        -> Tot nat (decreases length l)
let rec pos id l =
  match length l with
  |_ -> if head l = id then 0 else 1 + pos id (tail l)
  
val ord : id:nat
        -> id1:nat {id <> id1}
        -> l:seq nat {mem id l /\ mem id1 l}
        -> Tot (b:bool {b = true <==> pos id l < pos id1 l})
let ord id id1 l = pos id l < pos id1 l *)

#push-options "--z3rlimit 50"
val union_s : a:concrete_st
            -> b:concrete_st
            -> Pure concrete_st
              (requires true)
              (ensures (fun u -> (forall e. mem e u <==> mem e a \/ mem e b) (*/\
                              (forall e e1. ((mem e a /\ mem e1 a /\ ord e e1 a) \/
                              (mem e b /\ mem e1 b /\ ord e e1 b) \/
                              (mem e a /\ mem e1 b /\ e >= e1) \/
                              (mem e b /\ mem e1 a /\ e > e1)) <==>
                              (mem e u /\ mem e1 u /\ ord e e1 u)*))) (decreases %[length a; length b])
let rec union_s l1 l2 =
  match length l1, length l2 with
  |0, 0 -> empty
  |0, _ -> l2
  |_, 0 -> l1
  |_, _ -> if (head l1 >= head l2) 
             then (mem_cons (head l1) (union_s (tail l1) l2);
                   cons (head l1) (union_s (tail l1) l2))
             else (mem_cons (head l2) (union_s l1 (tail l2));
                   cons (head l2) (union_s l1 (tail l2)))
#pop-options

(*val remove : x:nat
           -> a:concrete_st
           -> Pure concrete_st
             (requires true)
             (ensures (fun r -> (forall e. mem e r <==> mem e a /\ e <> x) /\ not (mem x r)))
             (decreases length a)
let rec remove x a =
  match length a with
  |0 -> empty
  |_ -> if x = head a 
          then remove x (tail a) 
          else (mem_cons (head a) (remove x (tail a));
                cons (head a) (remove x (tail a)))

val diff_s : a:concrete_st -> l:concrete_st 
           -> Pure concrete_st
             (requires true)
             (ensures (fun r -> (forall e. mem e r <==> mem e a /\ not (mem e l))))
             (decreases length l)
let rec diff_s a l = 
  match length l with
  |0 -> a
  |_ -> diff_s (remove (head l) a) (tail l)

let lem_diff_s (a l:concrete_st)
  : Lemma (ensures ((l = a) ==> (diff_s a l == empty)))
    (decreases length l) = admit()

let lem_union_s (a b:concrete_st)
  : Lemma (ensures ((a = empty) ==> (union_s a b == b)) /\
                   ((b = empty) ==> (union_s a b == a))) =
  admit()*)

let is_prefix_s (p l:concrete_st) : Tot prop =
  Seq.length l >= Seq.length p /\ Seq.equal p (Seq.slice l 0 (Seq.length p))

let is_suffix_s (s l:concrete_st) : Tot prop =
  Seq.length l >= Seq.length s /\ Seq.equal s (Seq.slice l (Seq.length l - Seq.length s) (Seq.length l))
  
let diff_s (s1:concrete_st) (lca:concrete_st{is_prefix_s lca s1}) 
  : Tot (l:concrete_st{(length s1 == length lca + length l) /\ (s1 == Seq.append lca l) /\
                       (forall e. mem e s1 <==> (mem e lca \/ mem e l)) /\
                       (forall op. mem op l ==> length s1 > length lca) /\
                       is_suffix_s l s1}) =
  let s = snd (split s1 (length lca)) in
  lemma_split s1 (length lca);
  lemma_mem_append lca s;
  s
  
// concrete merge pre
let concrete_merge_pre (lca s1 s2:concrete_st) = 
  is_prefix_s lca s1 /\
  is_prefix_s lca s2
  //(forall e. mem e lca <==> mem e s1 /\ mem e s2) /\
  //(forall e. mem e (diff_s s1 lca) ==> not (mem e (diff_s s2 lca)))

#push-options "--z3rlimit 50"
let concrete_merge (lca s1:concrete_st) (s2:concrete_st{concrete_merge_pre lca s1 s2}) 
  : Tot (r:concrete_st{(forall e. mem e r ==> mem e lca \/ mem e s1 \/ mem e s2) /\
                       ((lca = s1) ==> ((diff_s s1 lca == empty) /\ (r == Seq.append (diff_s s2 lca) lca))) /\
                       ((lca = s2) ==> ((diff_s s2 lca == empty) /\ (r == Seq.append (diff_s s1 lca) lca)))}) = 
  let la = diff_s s1 lca in
  let lb = diff_s s2 lca in
  let u = union_s la lb in 
  lemma_mem_append u lca;
  Seq.append u lca
  //let r = union_s u lca in 
  //r
  
  (*|x::xs,y::ys,[] -> if lt (fst x) (fst y) then y::concrete_merge lca ys s2
                     else x::concrete_merge xs s1 s2
  |[],y::ys,z::zs -> if lt (fst y) (fst z) then z::concrete_merge lca s1 zs
                     else y::concrete_merge lca ys s2
  |x::xs,[],z::zs -> if lt (fst x) (fst z) then z::concrete_merge lca s1 zs
                     else x::concrete_merge xs s1 s2
  |x::xs,y::ys,z::zs -> if lt (fst x) (fst y) && lt (fst x) (fst z)
                       then if lt (fst y) (fst z) then z::concrete_merge lca s1 zs
                            else y::concrete_merge lca ys s2s
                       else *)

let linearizable_s1_0''_base_pre (lca s1 s2':st) (last2:op_t)
  : Lemma (requires is_prefix (ops_of lca) (ops_of s1) /\
                    is_prefix (ops_of lca) (ops_of s2') /\
                    is_prefix (ops_of lca) (snoc (ops_of s2') last2) /\
                    ops_of s1 = ops_of lca /\ ops_of s2' = ops_of lca /\
                    (forall id id1. mem_id id (ops_of lca) /\ mem_id id1 (diff (ops_of s1) (ops_of lca)) ==> lt id id1) /\
                    (forall id id1. mem_id id (ops_of lca) /\ mem_id id1 (diff (ops_of s2') (ops_of lca)) ==> lt id id1) /\
                    (forall id. mem_id id (diff (ops_of s1) (ops_of lca)) ==> not (mem_id id (diff (ops_of s2') (ops_of lca)))) /\
                    (forall id. mem_id id (ops_of lca) ==> lt id (fst last2)) /\
                    concrete_merge_pre (v_of lca) (v_of s1) (do (v_of s2') last2) /\
                    length (ops_of lca) > 0)
        
          (ensures (let l' = inverse_st lca in
                    let s1' = inverse_st s1 in
                    let s2'' = inverse_st s2' in
                    concrete_merge_pre (v_of l') (v_of s1') (do (v_of s2'') last2))) = ()

#push-options "--z3rlimit 50"
let linearizable_s1_0''_base_base (lca s1 s2':st) (last2:op_t)
  : Lemma (requires is_prefix (ops_of lca) (ops_of s1) /\
                    is_prefix (ops_of lca) (ops_of s2') /\
                    is_prefix (ops_of lca) (snoc (ops_of s2') last2) /\
                    ops_of s1 = ops_of lca /\ ops_of s2' = ops_of lca /\
                    length (ops_of lca) = 0 /\
                    (forall id id1. mem_id id (ops_of lca) /\ mem_id id1 (diff (ops_of s1) (ops_of lca)) ==> lt id id1) /\
                    (forall id id1. mem_id id (ops_of lca) /\ mem_id id1 (diff (ops_of s2') (ops_of lca)) ==> lt id id1) /\
                    (forall id. mem_id id (diff (ops_of s1) (ops_of lca)) ==> not (mem_id id (diff (ops_of s2') (ops_of lca)))) /\
                    (forall id. mem_id id (ops_of lca) ==> lt id (fst last2)) /\
                    concrete_merge_pre (v_of lca) (v_of s1) (do (v_of s2') last2))
        
          (ensures eq (do (v_of s2') last2) (concrete_merge (v_of lca) (v_of s1) (do (v_of s2') last2))) = admit();
  assume (concrete_merge (v_of lca) (v_of s1) (do (v_of s2') last2) == (do (v_of s2') last2)); ()

let linearizable_s1_0''_pre (lca s1 s2':st) (last2:op_t)
  : Lemma (requires is_prefix (ops_of lca) (ops_of s1) /\
                    is_prefix (ops_of lca) (ops_of s2') /\
                    is_prefix (ops_of lca) (snoc (ops_of s2') last2) /\
                    ops_of s1 = ops_of lca /\
                    (forall id id1. mem_id id (ops_of lca) /\ mem_id id1 (diff (ops_of s1) (ops_of lca)) ==> lt id id1) /\
                    (forall id id1. mem_id id (ops_of lca) /\ mem_id id1 (diff (ops_of s2') (ops_of lca)) ==> lt id id1) /\
                    (forall id. mem_id id (diff (ops_of s1) (ops_of lca)) ==> not (mem_id id (diff (ops_of s2') (ops_of lca)))) /\
                    (forall id. mem_id id (ops_of lca) ==> lt id (fst last2)) /\
                    concrete_merge_pre (v_of lca) (v_of s1) (do (v_of s2') last2) /\
                    length (ops_of s2') > length (ops_of lca))
       
          (ensures (let inv2 = inverse_st s2' in
                    concrete_merge_pre (v_of lca) (v_of s1) (do (v_of inv2) last2))) = ()

#push-options "--z3rlimit 50"
let linearizable_s1_0''_base_ind (lca s1 s2':st) (last2:op_t)
  : Lemma (requires is_prefix (ops_of lca) (ops_of s1) /\
                    is_prefix (ops_of lca) (ops_of s2') /\
                    is_prefix (ops_of lca) (snoc (ops_of s2') last2) /\
                    ops_of s1 = ops_of lca /\ ops_of s2' = ops_of lca /\
                    length (ops_of lca) > 0 /\
                    (forall id id1. mem_id id (ops_of lca) /\ mem_id id1 (diff (ops_of s1) (ops_of lca)) ==> lt id id1) /\
                    (forall id id1. mem_id id (ops_of lca) /\ mem_id id1 (diff (ops_of s2') (ops_of lca)) ==> lt id id1) /\
                    (forall id. mem_id id (diff (ops_of s1) (ops_of lca)) ==> not (mem_id id (diff (ops_of s2') (ops_of lca)))) /\
                    (forall id. mem_id id (ops_of lca) ==> lt id (fst last2)) /\

                    (let l' = inverse_st lca in
                    let s1' = inverse_st s1 in
                    let s2'' = inverse_st s2' in
                    is_prefix (ops_of l') (ops_of s1') /\ 
                    is_prefix (ops_of l') (ops_of s2'') /\
                    is_prefix (ops_of l') (snoc (ops_of s2'') last2) /\
                    ops_of s1' = ops_of l' /\ ops_of s2'' = ops_of l' /\
                    (forall id id1. mem_id id (ops_of l') /\ mem_id id1 (diff (ops_of s1') (ops_of l')) ==> lt id id1) /\
                    (forall id id1. mem_id id (ops_of l') /\ mem_id id1 (diff (ops_of s2'') (ops_of l')) ==> lt id id1) /\
                    (forall id. mem_id id (diff (ops_of s1') (ops_of l')) ==> not (mem_id id (diff (ops_of s2'') (ops_of l')))) /\
                    concrete_merge_pre (v_of lca) (v_of s1) (do (v_of s2') last2) /\
                    concrete_merge_pre (v_of l') (v_of s1') (do (v_of s2'') last2) /\
                    eq (do (v_of s2'') last2) (concrete_merge (v_of l') (v_of s1') (do (v_of s2'') last2))))

          (ensures eq (do (v_of s2') last2) (concrete_merge (v_of lca) (v_of s1) (do (v_of s2') last2))) = admit()

let linearizable_s1_0''_ind (lca s1 s2':st) (last2:op_t)
  : Lemma (requires is_prefix (ops_of lca) (ops_of s1) /\
                    is_prefix (ops_of lca) (ops_of s2') /\
                    is_prefix (ops_of lca) (snoc (ops_of s2') last2) /\
                    ops_of s1 = ops_of lca /\
                    length (ops_of s2') > length (ops_of lca) /\
                    (forall id id1. mem_id id (ops_of lca) /\ mem_id id1 (diff (ops_of s1) (ops_of lca)) ==> lt id id1) /\
                    (forall id id1. mem_id id (ops_of lca) /\ mem_id id1 (diff (ops_of s2') (ops_of lca)) ==> lt id id1) /\
                    (forall id. mem_id id (diff (ops_of s1) (ops_of lca)) ==> not (mem_id id (diff (ops_of s2') (ops_of lca)))) /\
                    (forall id. mem_id id (ops_of lca) ==> lt id (fst last2)) /\

                    (let inv2 = inverse_st s2' in
                    is_prefix (ops_of lca) (ops_of inv2) /\
                    is_prefix (ops_of lca) (snoc (ops_of inv2) last2) /\
                    (forall id id1. mem_id id (ops_of lca) /\ mem_id id1 (diff (ops_of inv2) (ops_of lca)) ==> lt id id1) /\
                    (forall id. mem_id id (diff (ops_of s1) (ops_of lca)) ==> not (mem_id id (diff (ops_of inv2) (ops_of lca)))) /\
                    concrete_merge_pre (v_of lca) (v_of s1) (do (v_of s2') last2) /\
                    concrete_merge_pre (v_of lca) (v_of s1) (do (v_of inv2) last2) /\
                    eq (do (v_of inv2) last2) (concrete_merge (v_of lca) (v_of s1) (do (v_of inv2) last2))))
        
          (ensures eq (do (v_of s2') last2) (concrete_merge (v_of lca) (v_of s1) (do (v_of s2') last2))) = admit()

let linearizable_s1_0_s2_0_base (lca s1 s2:st)
  : Lemma (requires is_prefix (ops_of lca) (ops_of s1) /\
                    is_prefix (ops_of lca) (ops_of s2) /\
                    ops_of s1 = ops_of lca /\ ops_of s2 = ops_of lca /\
                    (forall id id1. mem_id id (ops_of lca) /\ mem_id id1 (diff (ops_of s1) (ops_of lca)) ==> lt id id1) /\
                    (forall id id1. mem_id id (ops_of lca) /\ mem_id id1 (diff (ops_of s2) (ops_of lca)) ==> lt id id1) /\
                    (forall id. mem_id id (diff (ops_of s1) (ops_of lca)) ==> not (mem_id id (diff (ops_of s2) (ops_of lca)))) /\
                    concrete_merge_pre (v_of lca) (v_of s1) (v_of s2))
        
          (ensures eq (v_of lca) (concrete_merge (v_of lca) (v_of s1) (v_of s2))) = ()

////////////////////////////////////////////////////////////////
//// Sequential implementation //////

// the concrete state 
type concrete_st_s = seq nat

// init state 
let init_st_s = empty

// apply an operation to a state 
let do_s (s:concrete_st_s) (op:log_entry) : concrete_st_s = cons (fst op) s

//equivalence relation between the concrete states of sequential type and MRDT
let eq_sm (st_s:concrete_st_s) (st:concrete_st) = st_s == st

//initial states are equivalent
let initial_eq _
  : Lemma (ensures eq_sm init_st_s init_st) = ()

//equivalence between states of sequential type and MRDT at every operation
let do_eq (st_s:concrete_st_s) (st:concrete_st) (op:log_entry)
  : Lemma (requires eq_sm st_s st)
          (ensures eq_sm (do_s st_s op) (do st op)) 
  = ()

////////////////////////////////////////////////////////////////
