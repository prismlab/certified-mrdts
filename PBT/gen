#require "qcheck.ml"

(*let op_gen (max_ver:int) (max_rep:int)  =
  let open QCheck.Gen in
  frequency [
    1, map3 (fun srcRid dstRid newVer -> 
        fun c -> createBranch c srcRid dstRid newVer) 
      (int_bound max_rep) (int_bound max_rep) (int_bound max_ver);
    
    2, map2 (fun srcRid newVer -> 
        fun c -> apply c srcRid newVer Incr) 
      (int_bound max_rep) (int_bound max_ver);
    
    3, map3 (fun r1 r2 newVer -> 
        fun c -> merge c r1 r2 newVer) 
      (int_bound max_rep) (int_bound max_rep) (int_bound max_ver);
  ];;

let op_seq_gen length max_ver max_rep = QCheck.Gen.(list_size (int_bound length) (op_gen max_ver max_rep))

let apply_op_sequence (ops: (config -> config) list) : config = List.fold_left (fun c op -> op c) init_config ops

let () = let sequence = QCheck.Gen.generate1 (op_seq_gen 20 10 3) in (* 10 operations, max version 9, max replica 1 *) 
let final_config = apply_op_sequence sequence in print_dag final_config*)

(*#require "qcheck.ml"

let op_gen (num_ver:int) (num_rep:int) =
  let open QCheck.Gen in

  (* Generate a list of unique versions based on the v1 number of versions *)
  let unique_versions_gen num_ver =
    let rec aux acc n =
      if n = 0 then return (List.rev acc)
      else
        let* v = int_range 0 (num_ver - 1) in
        if List.mem v acc then aux acc n
        else aux (v :: acc) (n - 1) in
    aux [] num_ver in

  (* Generate unique versions *)
  let* unique_versions = unique_versions_gen num_ver in

  (* Generator for createBranch operation *)
  let createBranch_gen =
    map3 (fun srcRid dstRid newVer ->
        fun c -> createBranch c srcRid dstRid newVer)
      (int_range 0 (num_rep - 1))
      (int_range 0 (num_rep - 1))
      (element unique_versions) in

  (* Generator for apply operation *)
  let apply_gen =
    map2 (fun srcRid newVer ->
        fun c -> apply c srcRid newVer Incr)
      (int_range 0 (num_rep - 1))
      (element unique_versions) in

  (* Generator for merge operation *)
  let merge_gen =
    map3 (fun r1 r2 newVer ->
        fun c -> merge c r1 r2 newVer)
      (int_range 0 (num_rep - 1))
      (int_range 0 (num_rep - 1))
      (element unique_versions) in

  frequency [
    1, createBranch_gen;
    2, apply_gen;
    3, merge_gen;
  ]

let op_seq_gen length num_ver num_rep =
  QCheck.Gen.(list_size (int_bound length) (op_gen num_ver num_rep))

(* Initialize configuration *)
let num_replicas = 3

let initR : RepSet.t = RepSet.of_list (List.init num_replicas (fun i -> i))
let initN v = v  (* No limit here, it should be dynamic *)
let initH r = r  (* No limit here, it should be dynamic *)
let initL v = OpSet.empty
let initG : dag = { 
  vertices = VerSet.empty; (* Start with an empty set, as versions will be added dynamically *)
  edges = []
}
let initVis : VisSet.t = VisSet.empty

let init_config = {r = initR; n = initN; h = initH; l = initL; g = initG; vis = initVis }

(* Apply operation sequence *)
let apply_op_sequence (ops: (config -> config) list) : config =
  List.fold_left (fun c op -> op c) init_config ops

(* Main function *)
let () =
  let sequence = QCheck.Gen.generate1 (op_seq_gen 20 10 num_replicas) in
  let final_config = apply_op_sequence sequence in
  print_dag final_config*)